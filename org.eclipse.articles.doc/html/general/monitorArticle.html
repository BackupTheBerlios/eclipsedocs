<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><!-- saved from url=(0067)http://www.eclipse.org/articles/treeviewer-cg/TreeViewerArticle.htm --><title>Building administrative applications in Eclipse</title>
<link rel="stylesheet" href="monitorArticle_files/default_style.css">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta content="MSHTML 5.50.4915.500" name="GENERATOR"></head>

<body link="#0000ff" vlink="#800080">
<div align="right">&nbsp; <font face="Times New Roman, Times, serif" size="2">Copyright © 2004 IBM Corporation.</font> 
<table border="0" cellpadding="2" cellspacing="0" width="100%">
  <tbody>
  <tr>
    <td colspan="2" align="left" bgcolor="#0080c0" valign="top"><b><font face="Arial,Helvetica"><font color="#ffffff">&nbsp;Eclipse Corner 
      Article</font></font></b></td></tr></tbody></table></div>
<div align="left">
<h1><img src="monitorArticle_files/Idea.jpg" height="86" width="120"></h1></div>
<p>&nbsp;</p>
<h1 align="center">Building administrative applications in Eclipse</h1>
<blockquote><b>Summary</b> <br>Eclipse is most commonly used as a
platform for tools that allow the user to construct or assemble an end
product out of development resources. It is less usual to use Eclipse
as an administrative tool for monitoring existing runtime systems or
applications. This article will describe some of the issues that arise
in this case and illustrate possible solutions.
It will show you can build an Eclipse perspective dedicated to the
monitoring task. Running processes are shown in a dedicated view which
always reflects their current state. You can start/stop the process,
manage connections, invoke operations that the server exposes, examine
server output and view events generated by the running applications. <p><b>By Doina Klinger and Chris Markes, IBM UK</b> (dklinger@uk.ibm.com, cmarkes@uk.ibm.com)<br>
    November 12, 2004</p>
</blockquote>
<hr width="100%">

<h2>Introduction</h2>
<p>Eclipse is mainly a development environment: you create applications and run them. Take the Java<sup>TM</sup>
Development Toolkit component:
applications are stored in Java packages and classes which correspond
to directories and files with .java extension respectively. The
applications are
built using the Java compiler and then executed. Projects are holders
for the various files that are stored in the
workspace. Depending of the nature of the file, a different type of
builder is applied to them.</p><p>
Administration applications are fundamentally different. In this case,
the user interacts with existing applications that typically run outside of the Eclipse
JVM,     possibly on a remote machine. We will  refer to these
external applications as <b>servers</b>,
since they typically perform some function on
behalf of some client. The servers already exist, though they can be
made to run from Eclipse or even developed from the same workspace.
Often servers are administered by a browser-based application. In this
article, we will show you how it can be done using Eclipse.</p>
<h2>Server administration sample</h2>

<p>We will show how  you can use Eclipse to manage external servers. Our server is a simple 
 phone directory  that holds data about people and their phone numbers. The 
<a href="#serverSection">server</a> exposes operations to add new entries, query the list of entries and find out how many you have.</p><p>To see the sample in action you'll need to <a href="http://eclipse.org/articles/Article-Monitor/monitorPlugin.jar">download</a>   it and  install it as a plug-in on Eclipse 3.0 and then start the workbench and open the Monitor perspective. 
In figure 1 you can see the sample when a few servers have been defined and data entries have been added.</p>
<p align="center"><img src="monitorArticle_files/sample1.jpg" border="0"><br>
  Figure 1. Monitor sample in action </p>

<p>
In the servers view, the icons indicate the state of the servers: a red
square shows the server being unavailable, a green triangle shows an
active server. The state is kept up to date by polling every ten
seconds. To create a new server entry, start the New Connection wizard
from the pulldown menu of the local toolbar of the Servers view
(highlighted in figure 1):</p>
<div align="center"><img src="monitorArticle_files/newServerWizard.gif" border="0"><br>Figure 2. Define a new server
</div>
<p>
Specify a name, a host, a port number and whether you can start and
stop the server from the workbench. Start the server by selecting the
Start option from the context menu (Figure 3). Add a few new entries.
You can see the server output in the console view. When you select a
server, the number of entries is shown in the status line and the
content in the detail view in the right hand side.</p>
<p align="center"><img src="monitorArticle_files/serverOperations.jpg" border="0"><br>Figure 3. Invoking operations on the server
</p>

<p>
The sample shows how you can monitor the state of a running system and
report back in the Monitor Log view events related to the state of the
server. Add entries until the maximum number of entries is reached and
you can see the event reported in the log . You can modify the server
preferences for the refresh interval and maximum number of entries.</p>
<p align="center"> <img src="monitorArticle_files/preferences.gif" border="0"><br>Figure 4. Server preferences
</p>


<h2>Modelling the server world</h2>
<p>
From the point of view of an administrative application, the world is
composed of the target systems being administered together with the
environment of the application itself. The figure below shows the
target servers running either on a different host or on the same
machine with the Eclipse workbench, though in a different JVM.</p>
<p align="center"><img src="monitorArticle_files/servers.gif" border="0">
<br>
Figure 5. Workbench and target servers</p>

<p>
The application requires an internal representation or model of the
target systems, which is used to hold information about their state and
attributes. In our example, we model individual target systems using
instances of ServerElement. The ServerElement class encapsulates
instance variables (exposed by accessor methods) relating to the target
server's location and a snapshot of its most recently observed
condition: </p>
<blockquote><pre><code>public class ServerElement implements IAdaptable, IWorkbenchAdapter 
{ 
<img src="monitorArticle_files/tag_1.gif" border="0" height="13" width="24"> // Target server location
  String name;	
  String hostname;
  int port;
  boolean local;
  
<img src="monitorArticle_files/tag_2.gif" border="0" height="13" width="24">  // Target server state
  boolean alive;
  boolean full;
  

<img src="monitorArticle_files/tag_3.gif" border="0" height="13" width="24">PhoneBookClient connection
<img src="monitorArticle_files/tag_4.gif" border="0" height="13" width="24">ServerLauncher launcher;

  ...
}</code></pre></blockquote>
<p>
The location information (<code><img src="monitorArticle_files/tag_1.gif" border="0" height="13" width="24"></code>)
is used when we establish a connection to interact with the target
system. These attributes are also exposed as properties of the object
using the PhoneBookServerPropertySource class, which allows us to plug
into the standard Properties view in the workbench. </p><p>
The alive and full attributes (<code><img src="monitorArticle_files/tag_2.gif" border="0" height="13" width="24"></code>)
are updated as a result of the listening on the target server, and
affect the way we display the server entry in the ServersView using
started or stopped icons.
</p><p>

The ServerElement class encapsulates a PhoneBookClient instance (<code><img src="monitorArticle_files/tag_3.gif" border="0" height="13" width="24"></code>),
which is the actual object used to communicate with the server and
handle the network operations involved in talking to the server (in our
case, a simple HTTP server). </p><p>
An optional ServerLauncher  field(<code><img src="monitorArticle_files/tag_4.gif" border="0" height="13" width="24"></code>)
is used for invoking the server application on the local system. We'll
cover the ServerLauncher in more detail in the launching servers
<a href="#launchServerSection">section</a>
later in the article.</p><p>Since
our sample application allows the administrator to interact with more
than one target server, we use the ServersModel class to bring together
multiple instances of ServerElement as a list. The interaction of these
classes is described in the following diagram:
</p>
<p align="center"> 
<img src="monitorArticle_files/classDiagramMain.gif" border="0"><br>Figure 6. Server model
</p>
<p> We next look into how to serialize  such a model.
</p>
<h2> Representing remote resources in the workspace</h2>
<h3>Beyond the workspace</h3>
<p>When we're using the Eclipse workbench to develop applications, the
resources we work with are generally local. The source files we create
reside in the workspace -- even if we use a repository to share them
with other developers -- and the built output of a project likewise
remains local. </p><p>
By contrast, when our task is to monitor and administer
remote systems, the content we need to display in the views we use
must be retrieved across the network. (We'll deal with issues of
'liveness' <a href="#monitoringSection">later</a> on in the
article.)</p><p>In
our example, the ServerElement is the class that represents the remote
system and is persisted locally. In our example, we provide a view,
PhoneBookServersListView, which is really a Navigator for servers. </p>

<p>At this point, we have to decide where to 
store the connection information representing remote systems. We can store them: 
 </p><ul>
 <li>
as
normal workspace resources in a file of certain type. <br>
They show up in the Navigator view and can be modified by an editor associated with this file type. </li>
	
	<li>
 as data specific and private to our plug-in  <br>
The plug-in metadata
area is available for this purpose. This area can't be seen
in the Navigator view, so we need to provide a specialized view to display a representation of this content.
</li> 
</ul>
We've chosen the second option above, though both are valid approaches.
Incidentally, if you've been using the CVS Repository Exploring
perspective, you've already been working with an example of the second
approach. The implications of the two approaches are contrasted below.
<p>
<table border="1">
	<tbody>
		<tr>
			<td width="477"><b>Using workspace resources</b></td>
			<td width="477"><b>Using private resource information (plug-in
			metadata)</b></td>
		</tr>
		<tr>
			<td width="477">Resources (representations of remote systems) are
			visible in the Navigator, and are available to other Eclipse tools</td>
			<td width="477">Resources are visible only via dedicated plug-in code
			(specialized views etc.)</td>
		</tr>
		<tr>
			<td width="477">Representations of remote systems created with New
			wizard (contribution to org.eclipse.ui.NewWizards)</td>
			<td width="477">Representations of remote systems created by a user
			action provided by plug-in code</td>
		</tr>
		<tr>
			<td width="477">'Content' of remote systems is accessed using an
			Editor</td>
			<td width="477">Content is accessed using specialized views</td>
		</tr>
		<tr>
			<td width="477">Multiple editor instances can be used to work with
			multiple remote systems simultaneously</td>
			<td width="477">View must specifically accommodate working with
			multiple remote systems if this is desired</td>
		</tr>
		<tr>
			<td width="477">Content can appear without customizing any
			perspective</td>
			<td width="477">Existing perspective must be customized by user (e.g.
			Window -&gt; Show View) or a specialized perspective provided</td>
		</tr>
	</tbody>
</table>
</p><h2> Persisting server references</h2>
<p>The .metadata directory of a workspace is considered to be a "black
box" where important information about the workspace structure, such as
a project's references or a resource's properties, are typically stored.
 The non-workspace
resources are stored on a per plug-in basis, typically all in one file.
</p><p>
In our example, the "resources" that we want to persist are
ServerElement objects, or, more precisely, those attributes needed to
establish a session with the remote process and interact with it --
name, host, port and the isLocal attribute. The other attributes of the
ServerElement which describe the state of the server at one moment are
transient and are not saved.</p><p>
In
/workspace/.metadata/.plugins/MonitorProject/connection.xml we save
information about connections in an XML format:</p>
<blockquote><pre><code>&lt;Monitor&gt; 
    &lt;Server Host="134.456.888.99" <span class="m">   IsLocal= "true" </span>
		<span class="t"></span>Name="MyConnection" Port="600" /&gt; 
    &lt;Server Host="334.553.636.44" <span class="t">IsLocal</span><span class="m">="</span>true<span class="m">"</span><span class="t"> </span>
		Name="OtherConnection" Port="600" /&gt; 
    &lt;Server Host="223.223.662.55" <span class="t">IsLocal</span><span class="m">="</span>false<span class="m">"</span><span class="t"> </span>
		Name="DomainConnection" Port="400" /&gt; 
&lt;/Monitor&gt;</code></pre></blockquote>
<p>The serialization of our server model is achieved in the following steps:</p>
<ul>
	<li>construct the java.io.File object representing the file where the     server elements are to be saved <br>We use the getStateLocation method on our plug-in to return the location
in the local file system of the plug-in state area for this plug-in (<img src="monitorArticle_files/tag_1.gif" border="0" height="13" width="24">).<blockquote><pre><img src="monitorArticle_files/tag_1.gif" border="0" height="13" width="24"><code> File connectionFile = MonitorProjectPlugin.getDefault().getStateLocation().append(<font color="#0000ff">"connection.xml"</font>).toFile();
<code>   if (!connectionFile.exists()) connectionFile.createNewFile();</code></code></pre></blockquote>
	
	
	</li>
	<li>on start-up read the content of the file to build the connection model<br>
	
	We use XMLMemento for easy manipulation of the XML file.
	We create a file reader for the connection file and an XMLMemento object from the
	reader (<code><img src="monitorArticle_files/tag_2.gif" border="0" height="13" width="24"></code>) corresponding to the <code>&lt;Monitor&gt;</code> tag. From the parent IMemento object, we extract the children entries for each Server. (
	<code><img src="monitorArticle_files/tag_3.gif" border="0" height="13" width="24"></code> ). We can now extract the attributes of the connection and initialize the in-memory model.<blockquote><pre><code>   FileReader reader = new FileReader(connectionFile);
<img src="monitorArticle_files/tag_2.gif" border="0" height="13" width="24"> memento = XMLMemento.createReadRoot(reader);
<img src="monitorArticle_files/tag_3.gif" border="0" height="13" width="24"> IMemento[] children =memento.getChildren(<font color="#8000ff">"Server"</font>);
   for (int i = 0; i &lt; children.length; i++) {
	String name = children[i].getString(<font color="#0000ff">"Name"</font>);
	//extract all attributes and build the servers model 
    }</code></pre></blockquote>
	</li>
	<li>when closing the connection view, serialize the connections from the model to the file.</li>
<p> We create an XMLMemento corresponding to our <code>&lt;Monitor&gt;</code> root (<code><img src="monitorArticle_files/tag_4.gif" border="0" height="13" width="24"></code>). We iterate through  the model and create a child memento for each server  (<code><img src="monitorArticle_files/tag_5.gif" border="0" height="13" width="24"></code>) and set its attributes. In the end, we save the XMLMemento data structure to the file
using a file writer(<code><img src="monitorArticle_files/tag_6.gif" border="0" height="13" width="24"></code>).</p>
<blockquote><pre><code>
   Iterator iterator = model.getContent().iterator()
<img src="monitorArticle_files/tag_4.gif" border="0" height="13" width="24"> XMLMemento memento = XMLMemento.createWriteRoot(<font color="#0000ff">"Monitor"</font>);		
   while (iterator.hasNext()) {
	DirectoryConnection conn =((DirectoryViewElement)iterator.next()).getConnection();
<img src="monitorArticle_files/tag_5.gif" border="0" height="13" width="24">      IMemento child = memento.createChild(<font color="#0000ff">"Server"</font>);
	child.putString(<font color="#0000ff">"Name"</font>, conn.getName());
	// the same for all attributes

   }
<img src="monitorArticle_files/tag_6.gif" border="0" height="13" width="24"> Writer writer = new FileWriter(connectionFile);
   memento.save(writer);	</code></pre></blockquote>

</ul>
<h2>	<a name="monitoringSection"></a>Monitoring and event notifications	</h2>
<h3>Is  the server still there?</h3>
<p>A key ingredient in monitoring running systems or processes is
knowing whether or not they're in a normal, healthy state. In the most
basic situations, it can be enough just to know whether a server is
running or stopped, but typically there are a number of other potential
conditions -- which depend upon the type of system being monitored --
that an administrator is interested in. Rather than having to go and
pro-actively query the state of the server, it's useful to have a
continuous indication of its health, much like the dashboard in your
car. You can tell at a glance if all's well, and only peek under the
hood if something lights up that tells you there's a problem. (Well,
that's the theory!)
 </p>
 <p>The
server view is our dashboard display showing at a quick glance the
state of the running applications. How this is put together is captured
in the class diagram from Figure 7. The view uses the model for its
label and content provider. The server model uses a background thread
to continually poll the target servers for which it contains
references. When a change occurs in the state represented by the model,
it generates a ServerEvent to notify listeners of the change. The
ServerListView registers itself as a ServerListener in order to receive
these notifications.</p>
<p>The server view needs to be up-to-date; a dashboard that shows your
petrol tank full when you are down to the last drops is of not much
use. Hence the view needs to be a server listener to react to the
changes. The ServerListener interface defines the following methods:</p>
<blockquote><pre>void serverStarted(ServerEvent event)
void serverStopped(ServerEvent event)
void serverUpdate(ServerEvent event)
void serverError(ServerEvent event)</pre></blockquote>
<p align="center"><img src="monitorArticle_files/classDiagramDetail.gif" border="0"><br>
Figure 7. Class diagram </p>
<p>The way the connection object works depends upon the nature of
the server. Our example uses an HTTP server which expects connections to
be short-lived (i.e. it is connectionless), and that means we need to
perform a 'normal' interaction with the server in order to determine if
it's still there. We won't illustrate the HTTP protocol handling here -- that's implemented in the PhoneBookClient class.</p><p>
The ServerListModel keeps up-to-date with the state of the target
servers it knows about by having a monitor thread class running in the
background and examining each server element in turn. The interaction
for one ServerElement is shown in the code snippet from below. For the
server element, we obtain its PhoneBookClient in order to invoke its
method that tells us how many entries the server contains(<code><img src="monitorArticle_files/tag_1.gif" border="0" height="13" width="24"></code>). There are two reasons for invoking this method. If we get any answer at all the server is running.  We use the return value (<code><img src="monitorArticle_files/tag_2.gif" border="0" height="13" width="24"></code>) to determine if the server is full. If we get an IOException (<code><img src="monitorArticle_files/tag_3.gif" border="0" height="13" width="24"></code>) , the server is stopped.</p><p>
The response from the server is used to generate events for registered
listeners (i.e. the servers view), using the notifyStarted and
notifyUpdate methods.</p>
<blockquote><pre>       ServerElement element = ..; 
       try  { 
         PhoneBookClient client = element.getPhoneBookClient(); 
<img src="monitorArticle_files/tag_1.gif" border="0" height="13" width="24">       int count = client.getEntryCount (); 
         if (element.isAlive () == false)  { 
            element.setAlive (true); 
            notifyStarted (new ServerEvent ("Server started", IStatus.INFO, element.getName())); 
         } 
<img src="monitorArticle_files/tag_2.gif" border="0" height="13" width="24">       if (element.isFull () == false &amp;&amp; count &gt;= maxEntries) { 
             element.setFull (true); 
             notifyUpdate (new ServerEvent ("Max number of entries reached", IStatus.WARNING, element.getName ())); 
         } else element.setFull(false); 
     } catch (IOException e) { 
<img src="monitorArticle_files/tag_3.gif" border="0" height="13" width="24">       if (element.isAlive () == true) { 
             element.setAlive (false); 
             notifyStarted (new ServerEvent ("Server stopped (" + e.toString () + ')', IStatus.INFO,  element.getName ())); 
         }</pre></blockquote>
<p>For servers that are connection-oriented (expect
clients to remain connected indefinitely), it may be sufficient simply
to assume that as long as the connection hasn't been broken, the server
is still available. For cases where we want to use more detailed
criteria to determine the health of a server, our connection object will
need to interact with the remote system and perform the necessary
operations to determine that state.
</p><h3>How is the server doing?</h3>
	<p>In addition to checking
whether a server is still running or not, the administrator might want
to get more details about the well being of a running application. One
way of doing this is by examining the Monitor Log view.<br>This view
records notifications from the server sent in the shape of a
ServerEvent. The view is consistent with the ErrorLog of the PDE
plug-in and it wraps a TableViewer. The entries are of our own type
ServerLogEntry, which wraps various details about the event, such as
the severity, detailed message, code, server name. <br>In our example, the type of
events that are recorded are server started and stopped, and an alarm
event. For illustration purposes, we have defined a (configurable)
limit of ten entries
as maximum to be held by a server and we can see the event being
reported when this number is reached. </p>
<p align="center"><img src="monitorArticle_files/logView.jpg" border="0"><br>
  Figure 8. Monitor log view </p>
<p>
The events are generated by the background thread of the server model
that monitors the remote servers. If one of the servers is killed
externally you can see the server's state being updated to stop and a
stopped event being generated.</p><p>
Thinking back to the dashboard, if a warning red light shows an unusual
condition, there's usually further investigation required. The
experienced mechanic wants to open the hood to see the internal
workings of
the running system. In our example, when the server and the log views
provide an indication of a problem, the administrator might want to
dig deeper to check the state of the server. </p><p>
In our example we have the ServerContentView in the right hand of the
perspective. This shows the details of our PhoneBookServer, namely the
names and phone numbers  corresponding to the server
selected in the Servers view. If the server is stopped, there is no
detailed content.</p>
<h2><a name="launchServerSection"></a>Launching server instances	</h2>
<p>
When developing applications destined to run in a server environment,
it&#8217;s useful to have an instance of the target server under the
control of the development environment. This allows the development
environment &#8211; i.e. the workbench &#8211; to be the single point of
control for running the application under development. (If the server
itself is the application being developed, the picture changes a
little.) A sample use is a test environment, though this function is
not limited to it.</p><p>
If the server is a separate, existing application, we need a way of
launching it from the workbench while making its output visible to the
developer. In order to do this we use the framework described in <a href="http://www.eclipse.org/articles/Article-Java-launch/launching-java.html">Launching
Java Application programmatically</a>.
</p><h3>
The ServerLauncher class
</h3>
<p>
An instance of a server launcher is associated with each server
instance that&#8217;s defined as local. (The local property exists in order
for us
to determine whether or not we can launch the defined server as a local
process.). The launcher is set on the <samp>start</samp> method oof the ServerElement and nulled up on the <samp>stop</samp>
and is used to determine the started/stopped status. The steps necessary to launch our phone server are detailed below:</p>
<ul>
	<li>gets the launch manager <code><img src="monitorArticle_files/tag_1.gif" border="0" height="13" width="24"></code></li>
	<li>constructs a launch configuration type and copy <code><img src="monitorArticle_files/tag_2.gif" border="0" height="13" width="24"></code></li>
	<li>set the attributes and classpath <code><img src="monitorArticle_files/tag_3.gif" border="0" height="13" width="24"></code></li>
	<li>launch the configuration <code><img src="monitorArticle_files/tag_4.gif" border="0" height="13" width="24"></code></li>
</ul>
<blockquote><pre>public ILaunch launch (String mainClassname, String args) throws IOException, CoreException {
<img src="monitorArticle_files/tag_1.gif" border="0" height="13" width="24">  ILaunchManager manager = DebugPlugin.getDefault ().getLaunchManager ();
    ILaunchConfigurationType type = manager.getLaunchConfigurationType 
			(IJavaLaunchConfigurationConstants.ID_JAVA_APPLICATION);
<img src="monitorArticle_files/tag_2.gif" border="0" height="13" width="24">  ILaunchConfigurationWorkingCopy config = type.newInstance (null, mainClassname);
		
    config.setAttribute (IJavaLaunchConfigurationConstants.ATTR_MAIN_TYPE_NAME, mainClassname);
    config.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROGRAM_ARGUMENTS, args);		
<img src="monitorArticle_files/tag_3.gif" border="0" height="13" width="24">  setClasspath (config);
<img src="monitorArticle_files/tag_4.gif" border="0" height="13" width="24">  return config.launch (ILaunchManager.RUN_MODE, new NullProgressMonitor ());
}</pre>
<p>The <code>setClasspath</code> method creates the list of classpath
entries by adding the JVM and all the required plug-ins and libraries.
For more details, see the code.</p>
</blockquote>

	<h2>Tying it all together</h2>
	
	<h3>The monitor perspective</h3>
	<p>Admittedly it is a bad idea to create your own perspective in
	Eclipse, you should aim to reuse the existing ones. We made an
	exception for this article, because no existing perspective seem to
	quite fit with the task of administering objects and for illustration
	purpose. </p><p>
	We use the <code>org.eclipse.ui.perspectives</code> extension point,
	giving it the class attribute which must implement the <code>org.eclipse.ui.IPerspectiveFactory</code>
	interface. The <code>createLayout</code> method arranges the views that
	are relevant to our monitoring application. The layout is defined
	around the editor area(top-right part). We don't actually have anything
	to edit so make the editor area not visible. To the left of it, there
	is the servers view. Replacing the editor area is a view that shows
	the  content of the selected server. At the bottom of the page, we show
	the monitor view and below the property view 
	and the console view.</p>
	<h3>Server preferences</h3>
	<p>We use <code>org.eclipse.ui.preferencePages</code> extension point
	with  <code>ServerPreferencePage</code> as its class attribute 
	to define two of the configuration attributes of the server. One of
	them is specific to our server, the maximum number of entries that the
	phone directory accepts. After this number is reached, alarms are sent
	to the log view if more entries are added. </p><p>
The second parameter is more generic and could be used for other
servers. It describes the refresh interval that the sample uses are to
maintain the status of the connections up to date. The line from below
is used to extract the preferred value of a parameter from the
preference store associated with our plug-in.</p><p>
<code>ServersPlugin.getDefault().getPreferenceStore().getInt("MAXIMUM_ENTRIES")</code></p>


	<h2><a name="serverSection">Server</a></h2>
	<p align="left">The
server we've supplied in our example is a simple HTTP server
representing a phone book. The server holds a set of phone number
entries in a Properties object, and supports a handful of HTTP requests
to query and update the content. The requests supported are
</p><ul>
	<li><code>/lookup?name=name</code>: returns the phone number entry for the given name</li>
	<li><code>/remove?name=name</code>: removes the phone number entry for the given name</li>
	<li><code>/update?name=name&amp;value=value</code>: creates or updates the phone number entry for the given name</li>
	<li><code>/count</code>: returns the number of phone number entries stored in the server</li>
	<li><code>/info</code>: returns a version string</li>
	<li><code>/</code>: returns the server's set of entries</li></ul>
<p> Much of the server's code is there simply to implement just enough of the 
  HTTP 1.1 protocol to support the necessary operations. We use a PhoneBookClient 
  object to construct the necessary queries and handle the responses. A java.net.URLConnection 
  provides the client-side implementation of the HTTP protocol, and the PhoneBookClient 
  simply creates URLConnection instances with the appropriate request URI for 
  each operation.</p>
<h2><a name="resourceSection"></a>Resources</h2>

<p> <a href="http://eclipse.org/articles/Article-Monitor/monitorPlugin.jar">Monitor sample</a></p>
<p><small>Java and all Java-based trademarks and logos are trademarks or
registered trademarks of Sun Microsystems, Inc. in the United States,
other countries, or both. <br>
Other company, product or service names may be trademarks or service marks of others
</small>
</p>
</body></html>