<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Building a Database Schema Diagram Editor with GEF</title>

<link rel="stylesheet" href="gef-schema-editor_files/default_style.css"></head>

<body link="#0000ff" vlink="#800080">
<div align="right">&nbsp; <font face="Times New Roman, Times, serif"><font size="-1">Copyright © 2004 Realsolve Solutions Ltd.</font></font></div>
&nbsp;
<div align="right"> 
  <table border="0" cellpadding="2" cellspacing="0" width="100%">
    <tbody>
      <tr> 
        <td colspan="2" align="left" bgcolor="#0080c0" valign="top"><b><font face="Arial,Helvetica"><font color="#ffffff">&nbsp;Eclipse Corner 
          Article</font></font></b></td>
      </tr>
    </tbody>
  </table>
</div>
<h1><img src="gef-schema-editor_files/Idea.jpg" border="0" height="86" width="120"></h1>
<center>
  <h1>Building a Database Schema Diagram Editor<br>
    with GEF</h1>
</center>

<blockquote>
<b>Summary</b>

<br>
  GEF is a very powerful framework for visually creating and editing models. With a small initial investment, 
  even the relative Eclipse novice can be quickly up and running, building applications with graphical editing capabilities. 
  To illustrate, this article uses a relational database schema diagram editor with a deliberately 
  simplified underlying model, but with enough bells and whistles to show some of the interesting features of GEF at work.
  <p><b> Phil Zoio, Realsolve Solutions Ltd.</b> <br>
    <font size="-1">September 27, 2004</font> </p>
</blockquote>

<hr width="100%">

<h2>Introduction</h2>
<p>
Having graphical editing capabilities can be a real asset, if not an
essential feature, for many tools and applications. Examples are not
hard to think of: UML tools, GUI builders, in fact, any application
which comprises a dynamic model which can be visualized. With GEF,
Eclipse developers have at their disposal a framework which can really
simplify development of graphical editors. This article uses a simple
but non-trivial example to show how a GEF application works - and what
you need to do to get it to perform its little miracles. </p>
<p>
The screenshot below shows what our example editor looks like. The edit
area uses a "flyout" palette which contains some very basic entries and
can be minimized to increase the editable screen area. On the right
side is a scrollable graphical viewer containing the tables and their
relationships.
</p>
<p> <img src="gef-schema-editor_files/editor.JPG" align="middle" height="645" width="597"></p>

<p> <img src="gef-schema-editor_files/tryit.gif" height="13" width="61"> Download and unzip the 
  example plug-in <a href="http://www.eclipse.org/articles/Article-GEF-editor/schemaeditor.zip">schemaeditor.zip</a> into your <i>eclipse/</i> 
  directory, then create a new diagram by launching the wizard from the File menu: 
  File -&gt; New -&gt; Example ... -&gt; GEF (Graphical Editing Framework) -&gt; Schema Diagram 
  Editor. </p>
    
<p>
At the heart of GEF is the <b>Model-View-Controller</b> pattern, discussed in Randy Hudson's introductory tutorial 
<i><a href="http://www-106.ibm.com/developerworks/opensource/library/os-gef/" target="_blank">How to Get Started with the GEF</a></i>, and also
providing a focus for much of this article.
</p>
<h2>The Model</h2>
<p>
The starting point for any GEF application is the model. This is what needs to be displayed, edited and persisted. 
Our somewhat oversimplified model contains the following classes:
</p>
<ul>
  <li><code>Table</code>: represents a relational database table. The only attribute that the table holds itself is the name</li>
  <li><code>Column</code>: represents a table column. Here we are interested in the column name and the type of data, which itself can either be <code>VARCHAR</code> or <code>INTEGER</code></li>
  <li><code>Relationship</code>: represents a primary key/foreign key relationship between two tables. 
  The foreign key table we denote the <b>source</b> of the relationship, while the primary key table is the <b>target</b>. 
  Note that our model applies a relationship directly between two tables, 
  rather than between foreign and primary key fields in the respective tables, 
  as we would in the real world</li>
  <li><code>Schema</code>: simply represents all the tables we plan to group together (and ultimately show on the same diagram)</li>
</ul>
Our model is extremely simple, but does at least include the two key forms of relationship in a typical GEF model:
<ul>
  <li>The <b>parent-child</b> relationship that exists between schemas and tables, and between tables and columns</li>
  <li><b>Connections</b> between different <b>nodes</b>.
In our example application, the connections are in the form of primary
key/foreign key relationships, with the nodes being the tables</li>
</ul>
<p>
Of course, we need to decide what we want our editor to be able to do with the model. Here, we want to be able to:
</p>
<ul>
  <li>lay our tables nicely on the diagram. The diagram must scale to accommodate any growth in our model, and should be readable</li>
  <li>add new tables to our schema, and new columns to our table, using either drag and drop or point and click</li>
  <li>directly
edit the names of the tables as well as both the names and types of our
columns. In both cases, we want validation to tell us when we are
typing in nonsense</li>  
  <li>use drag and drop to set up relationships between tables, as well as to change these relationships</li>
  <li>use drag and drop to move column definitions from one table to another, or to reorder columns within tables</li>     
  <li>be able to delete tables, columns and relationships by hitting the delete key</li>  
  <li>have
a choice between manually laying out our diagram, and having this done
automatically. When using manual layout, we want to be able to shift
our tables around using drag and drop</li>     
</ul>
There are of course many more things we would like to be able to do with our editor, 
but we have enough here to be able to test out many of the most commonly used GEF features.
<h2>The View</h2>

<h3>Figures</h3>
<p>
The display component in both GEF and draw2d is built around the draw2d <code>IFigure</code> interface. 
Figures in draw2d are lightweight objects which can be nested to create a complex graphical representation.
The view is created by rendering and laying out the set of figures which reflect the model. 
In a typical GEF application, you would normally create a set of customized <code>IFigure</code> implementations, each subclassing <code>Figure</code>. 
</p>

<p>
<img src="gef-schema-editor_files/tip.gif" height="13" width="62"> 
If you're unfamiliar with draw2d and <code>Figures</code>, take a look at Daniel Lee's article on <i><a href="http://www.eclipse.org/articles/Article-GEF-Draw2d/GEF-Draw2d.html">Display a UML Diagram using Draw2D</a></i>, 
</p>

<p>
In our application we have the following figures:
</p><ul>
  <li><code>EditableLabel</code>: a subclass of the draw2d <code>Label</code> class which itself
    subclasses <code>Figure</code>. We need this for the column and table names</li>
  <li><code>ColumnsFigure</code>: a container for all the column labels</li>
  <li><code>TableFigure</code>: contains an <code>EditableLabel</code> for the table name, as well as a <code>ColumnsFigure</code> for the column names</li>
  <li><code>SchemaFigure</code>: a container for all the <code>TableFigures</code> in the schema</li>   
</ul>
<p>
We haven't provided any custom figures to represent connections - we simply use the draw2d <code>PolylineConnection</code> class, 
which is a just a line with zero or more kinks or bend points.
</p>
<p>
Because the table names as well as the number of columns and their names are likely to change during the lifetime of a <code>TableFigure</code> instance, 
we want our <code>ColumnsFigure</code> and <code>TableFigure</code> to be resizable. 
A key role in allowing this to happen is played by layout managers, another important part of the draw2d framework.
</p>

<h3>Layout Management</h3>
<p>
GEF provides a layout management framework which is distinct from the Swing and Eclipse SWT layout managers: 
its job is specifically to handle layout of the child figures of draw2d <code>IFigure</code> instances. 
Your job as an application developer is to decide which layout manager to use
for each figure containing child figures.</p> 
<p>
Broadly speaking, there are three types of layout managers:
</p><ul>
  <li><b>Structured layout managers</b>, such as <code>FlowLayout</code> and <code>ToolbarLayout</code>, 
  which lay out child figures according to their <b>order</b> by arranging them vertically or horizontally
  </li><li><b>Constraint-based layout managers</b>, such as the <code>XYLayout</code> and the <code>DelegatingLayout</code>. 
  Here the application itself participates directly in the placement of figures by setting a constraint <code>Object</code> 
  for each child figure. In the case of the <code>XYLayout</code>, this object is a <code>Rectangle</code> 
  with specified location and size</li>
  <li>
  <b>Layout using geometry computation algorithms</b>. Here layout is determined by applying a series of rather complex algorithms to 
  calculate the "best" layout for child figures. The algorithms take a specially constructed data structure as input and 
  deliver as their output a solution to geometrical problems such as node placement and routing of paths.
  The algorithms provided by GEF are in the classes <code>DirectedGraphLayout</code>
  and <code>CompoundDirectedGraphLayout</code>
  </li>
</ul>
<p>
The GEF developer needs to understand which layout managers can be best applied in which situation. 
Structured layout managers are suitable when there is a well defined parent-child relationship between the 
containing figure and its children <i>and</i>
the children are not related to each other in arbitrary ways.
In our example application, <code>TableFigure</code> uses a <code>ToolbarLayout</code> to place its children 
(simply stacking them vertically). The <code>ColumnsFigure</code> does the same with its child <code>Label</code> objects, 
but uses the <code>FlowLayout</code> for this purpose. 
</p><p>
This kind of arrangement of course does not work with <code>SchemaFigure</code> - 
any of its child <code>TableFigures</code> may be related to any other via a primary key/foreign key relationship, 
so we cannot simply stack the table figures next to each other or side by side.
For <code>SchemaFigure</code> we need to choose between either a constraint-based layout manager or a graph layout manager. 
In our example application we use both. Users can switch between manual layout, which involves dragging table figures 
to their desired locations, and automatic placement of figures using geometry computation algorithms. 
How this is done is beyond the scope of this article, 
although interested readers can examine the 
<code>DelegatingLayoutManager</code> class in the example application source code.

</p><p>
<img src="gef-schema-editor_files/tryit.gif" height="13" width="61">  Open a schema diagram editor and make some changes, switching between manual 
and automatic layout using the
<img src="gef-schema-editor_files/layout.gif" height="16" width="16"> icon.
</p>

<h2>The Controller</h2>
<p>
We only really move into GEF territory proper when we start talking about the controller in the MVC trilogy. 
GEF provides an abstraction that prevents the model from having to know about the figures, and vice versa. 
At the centre of this architecture is the <code>EditPart</code> interface.
</p>
<h3>EditParts</h3>
<p>
The first thing to know is that typically every separately editable part of the model will need to be
associated with an <code>EditPart</code> instance. This means that there will usually be a close to one-for-one mapping between classes 
in the model hierarchy and classes in the <code>EditPart</code>  hierarchy. 
In most cases, an <code>EditPart</code> is also a <code>GraphicalEditPart</code>, which means that
as well as managing a model component, it also has an associated view component. Because the 
model and view are completely decoupled, all coordination between the model and the view must be managed by the <code>EditPart</code>.
This coordination can be divided into two separate areas of activity:
</p><ol>
  <li>Acting as a listener to changes in the model so that
these can be propagated to the view, by calling layout related methods.
We discuss this in detail in the section <a href="#viewUpdate">Updating an Repainting the Display</a>
  </li>
  <li>Providing a means by which user interaction can be interpreted and propagated to changes in the model. 
  Central to this are <code>EditPolicies</code>, discussed in the section <a href="#editPolicies">EditPolicies and Roles</a>
  </li>
  <li>Managing what are known as direct edits, where the user types text directly into an editable control
  </li>
</ol> 
In our example application we have the following <code>EditPart</code> implementations
<ul>
  <li><code>SchemaDiagramPart</code>: represents a <code>Schema</code> instance and associated <code>SchemaFigure</code></li>
  <li><code>TablePart</code>: represents a <code>Table</code> and manages the <code>TableFigure</code> and child view components</li>
  <li><code>ColumnPart</code>: enables editing functionality for the column label</li> 
  <li><code>RelationshipPart</code>: represents a primary key/foreign key relationship. 
  In the same way that Relationship in the model is associated with two <code>Table</code> instances, 
  a <code>RelationshipPart</code> is associated with two <code>TableParts</code></li>  
</ul>
<p>
When an instance of any of these classes is created, it is automatically associated with a part of the model. 
This is a build-in feature of the framework. As part of our editor, we have to provide an <code>EditPartFactory</code> implementation. 
Ours looks like this:
</p>
<font color="#0000cc">
<pre>public class SchemaEditPartFactory implements EditPartFactory
{
    public EditPart createEditPart(EditPart context, Object model)
    {
        EditPart part = null;
        if (model instanceof Schema)
            part = new SchemaDiagramPart();
        else if (model instanceof Table)
            part = new TablePart();
        else if (model instanceof Relationship)
            part = new RelationshipPart();
        else if (model instanceof Column)
            part = new ColumnPart();
        part.setModel(model);
        return part;
    }
}</pre>
</font>
<p>
<code>SchemaDiagramPart</code>, <code>TablePart</code> and <code>ColumnPart</code> 
all extend <code>AbstractGraphicalEditPart</code> and implement <code>GraphicalEditPart</code>. 
In addition, <code>TablePart</code> can be a <i>node</i> in a primary/foreign key relationship, 
so it has to implement <code>NodeEditPart</code>.
Finally, <code>RelationshipPart</code> represents the <i>connection</i> part of the relationship, 
so it extends <code>AbstractConnectionEditPart</code>.
</p>
<p>
<code>SchemaDiagramPart</code>'s job is primarily managing the layout of the tables. 
<code>ColumnPart</code>'s role is relatively limited - it just needs to handle editing of the label displaying name and type information.
</p>
<p>
Of the four of these, <code>TablePart</code> has the most to do. 
In GEF, most of the work that is done to manage relationships is done
by <code>NodeEditPart</code>, and not <code>ConnectionEditPart</code>. 
Because we sometimes need to rename tables, <code>TablePart</code> also has to manage
editing of the label that displays its name. 
We will spend more of our time focusing on <code>TablePart</code>.
</p>


In a GEF application, there are a number of tasks <code>EditPart</code> subclasses must
fulfill:
<ol>
  <li>
  <p>
  Provide a figure instance to be associated with the <code>EditPart</code>. 
  In the case of <code>TablePart</code>, we simply return a new <code>TableFigure</code> instance with a name label:
<font color="#0000cc">
<pre>  protected IFigure createFigure()
  {
      Table table = getTable();
      EditableLabel label = new EditableLabel(table.getName());
      TableFigure tableFigure = new TableFigure(label);
      return tableFigure;
  }</pre>
  </font>
  
	</p></li><li>		
	<p>  
	<code>EditParts</code> which represent parent objects in <b>parent-child</b> relationships need to override <code>getModelChildren()</code>. 
	In the case of <code>TablePart</code>, our
	implementation of this method simply returns the <code>Column</code> objects it contains:
<font color="#0000cc">
<pre>  protected List getModelChildren()
  {
      return getTable().getColumns();
  }</pre>
</font>	
	Note that the <code>AbstractEditPart</code> implements a parallel method <code>getChildren()</code>, 
	which returns the <code>EditPart</code> collection representing the model children.
	In the case of <code>TablePart</code>, <code>getChildren()</code> returns a list of <code>ColumnPart</code> objects. 
	We know this because our implementation of <code>EditPartFactory</code> associates 
	<code>Column</code> model instances with instances of <code>ColumnPart</code>.
	The <code>EditPart</code> <code>List</code> returned by <code>getChildren()</code> 
	always needs to be kept in sync with the <code>getModelChildren()</code>. 
	In the Section <a href="#synchronising">Synchronizing EditPart Relationships with Model Changes</a> we describe how this happens
	<br>
	
	</p></li><li>
	<p>
	If the parent <code>EditPart</code>'s figure is not the direct parent of the child <code>EditPart</code>'s figure, you will
	need to override <code>AbstractGraphicalEditPart.getContentPane()</code>.	
	The <b>content pane</b> is the containing figure into which GEF adds figures created by child <code>EditParts</code>,
	which is by default the figure returned by the <code>EditPart</code>'s <code>createFigure()</code> method.
	</p>
	<p>
	In our example application
	the column labels are not contained within a <code>TableFigure</code> but within its <code>ColumnsFigure</code> child. 
	Our implementation of <code>getContentPane()</code> in <code>TablePart</code> reflects this:
</p><pre>public IFigure getContentPane()
{
    TableFigure figure = (TableFigure) getFigure();
    return figure.getColumnsFigure();
}</pre>			
<p>
<img src="gef-schema-editor_files/tip.gif" height="13" width="62"> Do not add and remove child figures 
by overriding <code>AbstractGraphicalEditPart.addChildVisual()</code> and <code>AbstractGraphicalEditPart.removeChildVisual()</code>.
Override <code>getContentPane()</code> instead.
</p>
  </li>
    <li>
    <code>EditParts</code> which represent nodes (model objects which may participate in connections) 
    must also implement a number of additional methods defined in the interface <code>NodeEditPart</code>
    <ul>
  		<li>
  		<p>
  		<code>protected List getModelSourceConnections()</code>: this returns all the connection model objects for which the 
  		node model object is the source.
  		In our example application, we have identified foreign keys as the source of a primary key/foreign key relationship. 
  		<code>TablePart</code>'s implementation contains just a single line of code:
  		</p>
  		<p>
  		<font color="#0000cc"><code>return getTable().getForeignKeyRelationships();</code></font>	
  		</p>
  		<p>
  		This method simply returns the <code>Relationship</code> objects for 
  		which the current <code>TablePart</code>'s <code>Table</code> is the foreign key. 
  		Once again, there is a parallel method <code>getSourceConnections()</code>, 
  		which returns the <code>List</code> of <code>RelationshipParts</code> associated with these relationships.
  		We also consider in the Section <a href="#synchronising">Synchronizing EditPart Relationships with Model Changes</a>
  		 how the <code>ConnectionEditPart</code> list returned by 
  		<code>getSourceConnections()</code> stays in sync with the 
  		<code>Relationship</code> list returned by <code>getModelSourceConnections()</code>
  		</p>
  		</li>
  		<li>
  		<p>
  		<code>protected List getModelTargetConnections()</code>: 
  		this works identically to <code>getModelSourceConnections()</code>, 
  		except that it returns the <code>Relationship</code> objects for which the current 
  		<code>TablePart</code>'s <code>Table</code> is the primary key
  		</p>
  		</li>
  		<li>
  		<p>
  		the node <code>GraphicalEditPart</code> must also provide implementations of the 
  		<code>NodeEditPart</code> <code>getSourceConnectionAnchor()</code> and <code>getTargetConnectionAnchor()</code> methods. 
  		In each case, these methods return objects which represent the points to which connections between nodes can be attached
  		</p>
  		</li>
  	</ul>
    </li>
    <li>Provide an implementation for <code>createEditPolicies()</code>, 
    during which <code>EditPolicy</code> implementations are associated with specific editing roles. 
    The <code>EditPolicy</code> and its associated roles, <code>Request</code> and 
    <code>Command</code> objects are a fundamental part of GEF which we discuss in the next sections
    </li>    
</ol>

<h3>Requests</h3>
<p>
We begin with requests because these are really the starting point of
the editing process that GEF application developer works with.
In fact, the real magic in GEF is being able to interpret user
interactions and transform
these into <b>requests</b>, 
which the application can work with in an object-oriented fashion. 
For example, when we drag from the "New Column" palette button onto an existing
table on the diagram, we are of course trying to add a new column to the table. 
As users interact with the application, GEF's behind-the-scenes work produces <code>Request</code> objects. 
In the create column example, GEF produces
a <code>CreateRequest</code>, which contains the following important information:
</p><ul>
  <li>the instance of the new model object that has been created 
  (but probably not yet configured and definitely not added to the rest of the model)</li>
  <li>The <code>EditPart</code> object which is hosting this request. 
  In our case this will be an instance of <code>TablePart</code></li>
</ul>
Different types of user interactions will produce different <code>Request</code>
types
- these are well covered in the GEF API and platform documentation.
These request objects neatly encapsulate the information the
application needs to transform user interaction into changes to the
model. We can take a look at how this is done once we have looked at <code>Commands</code> and <code>EditPolicies</code>, 
which we cover in the next section. 



<a name="editPolicies"></a>
<h3>EditPolicies and Roles</h3>
<p>
An <code>EditPolicy</code> is really just an extension of an <code>EditPart</code>, 
in the sense that certain editing related tasks are passed on from the <code>EditPart</code> to its <code>EditPolicy</code> delegates.
<code>EditPart</code> implementations would rapidly become bloated if they had to take on everything that <code>EditPolicies</code> do. 
To understand what an <code>EditPolicy</code> is and what it does, 
lets start by looking at the <code>createEditPolicies()</code> method in <code>TablePart</code>:
<font color="#0000cc">
<pre>protected void createEditPolicies()
{
    installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE, new TableNodeEditPolicy());
    installEditPolicy(EditPolicy.LAYOUT_ROLE, new TableLayoutEditPolicy());
    installEditPolicy(EditPolicy.CONTAINER_ROLE, new TableContainerEditPolicy());
    installEditPolicy(EditPolicy.COMPONENT_ROLE, new TableEditPolicy());
    installEditPolicy(EditPolicy.DIRECT_EDIT_ROLE, new TableDirectEditPolicy());
}</pre>
</font>
</p><p>
The purpose of this method is simply to decorate the <code>TablePart</code> with editing functionality. 
Each call to <code>installEditPolicy()</code> in the above method 
registers an <code>EditPolicy</code> with the <code>EditPart</code>. 
The key constant used in each of these calls is the name of the <b>role</b> used. 
For example, <code>EditPolicy.CONTAINER_ROLE</code> is 
simply the string <i>"ContainerEditPolicy"</i>. 
The container role is relevant for <code>TablePart</code> because we know that tables contain
columns, and one of our application's requirements is to create new columns 
and add these to existing tables.
</p>
<p>
The use of a particular role name in the <code>installEditPolicy()</code> call is really just a convention - the framework does not 
attach any behavior to a particular choice of role name. 
What distinguishes an <code>EditPolicy</code> implementation (and its corresponding role) is the type of requests it understands. 
Most of the abstract <code>EditPolicy</code> classes
provide an implementation of the <code>getCommand(Request request)</code> method.
</p> 
<p> 
In <code>ContainerEditPolicy</code> we find the following:

<font color="#0000cc">
<pre>public Command getCommand(Request request) {
  if (REQ_CREATE.equals(request.getType()))
	return getCreateCommand((CreateRequest)request);
  if (REQ_ADD.equals(request.getType()))
	return getAddCommand((GroupRequest)request);
  if (REQ_CLONE.equals(request.getType()))
	return getCloneCommand((ChangeBoundsRequest)request);
  if (REQ_ORPHAN_CHILDREN.equals(request.getType()))
	return getOrphanChildrenCommand((GroupRequest)request);
  return null;
}</pre>
</font>
</p><p>
Here <code>getCommand()</code> simply uses the request type to determine which <code>getXXXCommand()</code> method to call. 
In <code>ContainerEditPolicy</code>, <code>getCreateCommand()</code> is abstract - 
we must provide an implementation in order to use the base <code>ContainerEditPolicy</code> functionality.
</p>
<p>
Here is our implementation of <code>TableContainerEditPolicy</code>:

<font color="#0000cc">
<pre>public class TableContainerEditPolicy extends ContainerEditPolicy
{
    protected Command getCreateCommand(CreateRequest request)
    {
    <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> Object newObject = request.getNewObject();
        if (!(newObject instanceof Column))
        {
            return null;
        }
        Column column = (Column) newObject;

    <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> TablePart tablePart = (TablePart) getHost();
        Table table = tablePart.getTable();
    <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> ColumnCreateCommand command = new ColumnCreateCommand();
        command.setTable(table);
        command.setColumn(column);
        return command;
    }
}</pre>
</font>
</p><p>
In most cases, our <code>EditPolicy</code> implementations simply amount to using a 
<code>Request</code> object to generate a <code>Command</code>. 
Our <code>getCreateCommand()</code> method 
</p><ul>
  <li><img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> gets the new object embodied in the <code>CreateRequest</code> 
  and makes sure that it is an instance of <code>Column</code>,</li>
  <li><img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> gets the <code>Table</code> object associated with 
  the host <code>EditPart</code>, and</li>
  <li><img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> creates an instance of the relevant <code>Command</code> class, 
  configures it with the <code>Table</code> and <code>Column</code> information, and returns it</li>
</ul>
Our <code>TablePart</code> <code>createEditPolicies()</code> implementation uses one of 
our customized <code>EditPolicy</code> implementations for each invocation of 
<code>installEditPolicy()</code>. 
Each of our <code>EditPolicy</code> implementations subclasses a GEF-provided abstract <code>EditPolicy</code> for a different role. 
For example, <code>TableEditPolicy</code> extends <code>ComponentEditPolicy</code> to
fulfill the <code>EditPolicy.COMPONENT_ROLE</code>. 
It does so by implementing the 
<code>createDeleteCommand(GroupRequest request)</code> to handle requests of type <code>REQ_DELETE</code>.
<p>
The GEF platform documentation provides a lot more detail on the types of roles and requests and how and when they can be used, 
so we won't cover them in any more detail here.
</p>
<h3>Commands</h3>

<p>
<code>Command</code> is GEF's abstract base class whose function is simply to encapsulate our application's response to a request.  
Key methods included in the <code>Command</code> class are the following: 
</p><ul>
  <li><code>execute()</code>:  
  <code>Command</code> provides a no-op implementation. As the name suggests, 
  this contains the code to apply any change to the model that the <code>Command</code> object encapsulates</li>
  <li><code>undo()</code>: used to reverse the effect of <code>execute()</code>. 
  Here <code>Command</code> also provides a no-op implementation</li>
  <li><code>redo()</code>: used redo a command execution. 
  The <code>Command</code> implementation simply calls <code>execute()</code>, which should usually be adequate</li>  
  <li><code>canExecute()</code>: whether <code>execute()</code> can be executed. 
  The subclass can implement this to specify the conditions under which the command can be executed</li>
  <li><code>canUndo()</code>: whether <code>undo()</code> can be executed. 
  The <code>Command</code> implementation simply returns true, which subclasses can override</li>
  <li><code>canRedo()</code>: whether <code>redo()</code> can be executed. The <code>Command</code> implementation here also simply returns true</li>
</ul>
<p>
Any non-trivial <code>Command</code> subclass would need to implement <code>execute()</code>. 
Implementation of <code>undo()</code> would be recommended in most cases. The other methods
are optional and would only be overridden as required.
</p>
<p>
Lets take a look at our rather straightforward <code>ColumnCreateCommand</code> implementation:

<font color="#0000cc">
<pre>public class ColumnCreateCommand extends Command
{
    private Column column;
    private Table table;

    public void setColumn(Column column)
    {
        this.column = column;
    <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> this.column.setName("COLUMN " + (table.getColumns().size() + 1));
        this.column.setType(Column.VARCHAR);
    }

    public void setTable(Table table)
    {
        this.table = table;
    }

    public void execute()
    {
    <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> table.addColumn(column);
    }

    public void undo()
    {
    <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> table.removeColumn(column);
    }
}</pre>
</font>
Much of the class is self-explanatory. 
We have setter methods to populate the <code>Command</code> object 
with the newly-created <code>Column</code> as well as the 
target container <code>Table</code>. 
We arbitrarily provide a name and type for the <code>Column</code> <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24">, 
which the user can later change.
We can also see that <code>execute()</code> <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24">
simply adds the <code>Column</code> object to the <code>Table</code>, 
and <code>undo()</code> <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> simply reverses that change.
</p><p>
The use of <code>Commands</code> has two key advantages over using <code>EditPolicies</code> directly to effect model changes
</p><ul>
  <li>Commands are more elegant and in line with OO best practice</li>
  <li>The <code>Command</code> framework has built-in support for undo and redo functionality</li>
</ul>
<p>
<img src="gef-schema-editor_files/tip.gif" height="13" width="62">  The <code>Command</code> implementation is closely tied to the model, 
and should be cleanly separated from GEF-specific components. 
It should not contain any references to <code>EditParts</code> or <code>EditPolicies</code>. 
Observing this rule preserves the clean separation
between commands and the UI logic, helping to keep code more maintainable and bug-free.
</p>


<h2>Propagating Model Changes</h2>

<p>
Once we've changed the model, our GEF editor needs to propagate these changes to the UI. Our model, view and controller need
to work together to achieve this.
</p>
<p>
So far, we have discussed the <code>GraphicalEditPart</code>'s responsibility to provide a figure 
to represent the part of the model it is managing.
To participate in a fully functional graphical editor, it needs to do more:
</p><ul>
  <li>It needs to act as a <b>listener</b> for changes in the model. 
  The model itself needs to <b>fire event notifications</b> which the <code>EditPart</code> can receive</li>
  <li>It needs to maintain its own 
  child and connection relationships with other <code>EditParts</code>, keeping these in sync with changes to the model</li>
  <li>It needs to update the figures that it is managing, and their layouts, in line with model changes</li>
</ul>
We discuss each of these in turn.

<h3>Sending and Receiving Event Notifications</h3>
<p>
The requirements imposed on our model implementation are that
</p><ol>
  <li>it exposes a mechanism by which listeners can register interest in event notifications, and</li>
  <li>it actually fires these event notifications at the appropriate times!</li>
</ol>
In our example application we want all our model objects to use a common framework, 
so we satisfy the first requirement by 
allowing all our model classes to extend <code>PropertyAwareObject</code>, which looks like this:

<font color="#0000cc">
<pre>public abstract class PropertyAwareObject implements Serializable
{

<img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> public static final String CHILD = "CHILD";
    ... other String constants representing the other types of model changes
	
    <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> protected transient PropertyChangeSupport listeners = new PropertyChangeSupport(this);

    protected PropertyAwareObject()
    {
    }

    public void addPropertyChangeListener(PropertyChangeListener l)
    {
    <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> listeners.addPropertyChangeListener(l);
    }

    public void removePropertyChangeListener(PropertyChangeListener l)
    {
    <img src="gef-schema-editor_files/tag_4.gif" align="middle" height="13" width="24"> listeners.removePropertyChangeListener(l);
    }
  
    protected void firePropertyChange(String prop, Object old, Object newValue)
    {
    <img src="gef-schema-editor_files/tag_5.gif" align="middle" height="13" width="24"> listeners.firePropertyChange(prop, old, newValue);
    }
    
    ...
}</pre>
</font>

Our abstract model base class 
contains a few <code>String</code> constants <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> 
representing the types of model changes it knows about. 
It uses the <code>java.beans.PropertyChangeSupport</code> <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24">
to provide the "plumbing" for the event handling. 
It also exposes methods <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> 
and <img src="gef-schema-editor_files/tag_4.gif" align="middle" height="13" width="24"> which observers can use to register and deregister their
interest in model changes. 
Finally, it includes a <code>firePropertyChange()</code> <img src="gef-schema-editor_files/tag_5.gif" align="middle" height="13" width="24"> method 
which subclasses can use to trigger property events.
In our example of adding a column to a table, we see a good example in <code>Table</code>:

<font color="#0000cc">
<pre>public void addColumn(Column column)
{
    columns.add(column);
    firePropertyChange(CHILD, null, column);
}</pre>
</font>

With this mechanism available, we now need to take advantage in our <code>EditPart</code> listeners. 
Once again, we address the issue
by providing a common base class for our <code>GraphicalEditParts</code> to extend, shown below:
  
<font color="#0000cc">
<pre>public abstract class PropertyAwarePart 
		extends AbstractGraphicalEditPart 
		implements PropertyChangeListener
{
    public void activate()
    {
        super.activate();
        PropertyAwareObject propertyAwareObject = (PropertyAwareObject) getModel();
    <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> propertyAwareObject.addPropertyChangeListener(this);
    }

    public void deactivate()
    {
        super.deactivate();
        PropertyAwareObject propertyAwareObject = (PropertyAwareObject) getModel();
    <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> propertyAwareObject.removePropertyChangeListener(this);
    }

    public void propertyChange(PropertyChangeEvent evt)
    {
    <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> //handle property change event 
        ...   
    }
}</pre>
</font>
The GEF API documentation recommends the use of <code>activate()</code> and <code>deactivate()</code> 
to register or deregister model listeners. 
This is what we do here. After casting our model object to <code>PropertyAwareObject</code>, 
we add our <code>EditPart</code> as a listener in <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24">, 
and allow it to be removed on deactivation in <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24">. 
Once the <code>EditPart</code> is activated, any event notifications fired from our model 
will result in an invocation of <code>propertyChange()</code> <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24">. 
Our <code>propertyChange()</code> implementation in <code>PropertyAwarePart</code> in turn delegates 
its response to other methods, which can be overridden by <code>EditPart</code> subclasses 
to customize reactions to specific changes in the model.

<a name="synchronising"></a>
<h3>Synchronizing EditPart Relationships with Model Changes</h3>
<p>
As we mentioned previously, the first thing the <code>EditPart</code> implementation needs to do in response to a model change is to 
ensure that its relationship hierarchy is in sync with that of the model. 
GEF provides a quick and easy solution in the form of three methods in the <code>EditPart</code> 
hierarchy. Before discussing
a more performant approach that many applications will demand, we'll take a look at these methods. 
</p><ul>
  <li><code>refreshChildren()</code>: when an <code>EditPart</code> represents a model object with children, 
  this method may need to be called. 
  Our example of adding a column to a table is a good one. The same applies for removing a column from a table.
  If we moved a column from one table to another, 
  <code>refreshChildren()</code> would need to be called for both corresponding <code>TableParts</code>. 
  The base implementation of this method not only synchronizes your model and <code>EditPart</code> hierarchies - 
  it also adds or removes visual components as required
  by calling the <code>AbstractGraphicalEditPart</code> <code>addChildVisual()</code> and <code>removeChildVisual()</code> methods
  </li>
  <li><code>refreshSourceConnections()</code>: this applies to any model change where the source of a connection 
  is added, removed or reassigned.
  For example, if we added or deleted a primary/foreign key relationship, this method would need to be called
  </li>
  <li>
  <code>refreshTargetConnections()</code>: this only applies to a model change where the target 
  of a connection is added, removed or reassigned. It would be needed for any change affecting 
  the primary key of a relationship between tables</li>
</ul>
<p>
Returning to our example of adding a column to a table, 
our implementation of <code>PropertyAwarePart.propertyChange()</code> can be
reduced to the following:
<a name="propertyChange"></a>
<font color="#0000cc">
</font></p><pre><font color="#0000cc">public void propertyChange(PropertyChangeEvent evt)
{
    String property = evt.getPropertyName();

    if (PropertyAwareObject.CHILD.equals(property))
    {
    <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> refreshChildren();
    <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> refreshVisuals();
    }
    ... handle other types of property changes here

}</font></pre>


To resynchronize the <code>EditPart</code> hierarchy, we simply call 
<code>refreshChildren()</code> <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24">. 
To update the display, we then call <code>refreshVisuals()</code> <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24">. 
We discuss the
mechanics and rationale for <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> 
in the next section.
<p>
Using the methods <code>refreshChildren()</code>, <code>refreshSourceConnections()</code> and <code>refreshSourceConnections()</code> 
can help you get your application working quickly, but if we want our application to run <b>efficiently</b>, 
we need to be more selective
in the methods we use. For example, to add or remove a child, we can use the <code>EditPart</code> methods 
<code>addChild(EditPart, int)</code> and <code>removeChild(EditPart)</code>. 
Our revised <code>handleChildChange(PropertyChangeEvent)</code>below is a better performing replacement for <code>refreshChildren()</code> 
which uses these methods:
<font color="#0000cc">
<pre>protected void handleChildChange(PropertyChangeEvent evt)
{
    Object newValue = evt.getNewValue();
    Object oldValue = evt.getOldValue();

    if (newValue != null)
    {
        //add new child
        <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> EditPart editPart = createChild(newValue);
        <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> int modelIndex = getModelChildren().indexOf(newValue);
        <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> addChild(editPart, modelIndex);
    }
    else
    {
        //remove an existing child
        List children = getChildren();

        EditPart partToRemove = null;
        for (Iterator iter = children.iterator(); iter.hasNext();)
        {
            EditPart part = (EditPart) iter.next();
            if (part.getModel() == oldValue)
            {
            <img src="gef-schema-editor_files/tag_4.gif" align="middle" height="13" width="24"> partToRemove = part;
                break;
            }
        }
        if (partToRemove != null)
        <img src="gef-schema-editor_files/tag_5.gif" align="middle" height="13" width="24"> removeChild(partToRemove);
    }
}</pre>
</font>
</p><p>
When adding our child, we need to call <code>createChild()</code> 
<img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> to get a new <code>EditPart</code> for the model child.
We then find the index of the model child in the containing <code>List</code><img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24">, 
and add our new child <code>EditPart</code> using this index <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24">. 
When removing a child, we iterate through the existing children
<code>EditParts</code> until we find the one representing the removed model child <img src="gef-schema-editor_files/tag_4.gif" align="middle" height="13" width="24">. 
We then remove this <code>EditPart</code> <img src="gef-schema-editor_files/tag_5.gif" align="middle" height="13" width="24">.
</p>
<p>
Clearly, there is more work here than in simply calling <code>refreshChildren()</code>: but for large models where performance is critical, this effort will be worth it. 
</p>
<p>
Interested readers can examine <code>handleInputChange(PropertyChangeEvent)</code> and <code>handleOuputChange(PropertyChangeEvent)</code> in
<code>PropertyAwarePart</code> 
for similar alternatives to <code>refreshSourceConnections()</code> and <code>refreshTargetConnections()</code> when updating relationships.
</p>

<a name="viewUpdate"></a>
<h3>Updating and Repainting the Display</h3>

<p>
Consider our example of adding a column to a table. In draw2d terms, 
this is represented by adding an <code>EditableLabel</code> into 
a <code>ColumnsFigure</code> instance, which is itself contained within a <code>TableFigure</code>. 
Both the <code>ColumnsFigure</code> and the <code>TableFigure</code> both need to enlarge 
- the result otherwise is ugly (take my word for it!).
</p>
<p>
A few things need to happen:
</p><ol>
  <li>The cached information held by the layout managers for the <code>TableFigure</code> and <code>ColumnsFigure</code>, 
  which includes minimum size and preferred size for the child figures, needs to be thrown away</li>
  <li>The <code>SchemaFigure</code>'s layout manager needs to 
  update any cached constraint information it is holding for the <code>TableFigure</code></li>
  <li>The bounds of both the <code>TableFigure</code> and the <code>ColumnsFigure</code> 
  need to change to reflect addition of the column&nbsp;</li> 
  <li>Any area affected by the change needs to be repainted</li>  
</ol>

<p>
In fact, all we need to achieve this is in our implementation of <code>refreshVisuals()</code> in <code>TablePart</code>:

<font color="#0000cc">
<pre>protected void refreshVisuals()
{
    TableFigure tableFigure = (TableFigure) getFigure();
<img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24"> Point location = tableFigure.getLocation();
    SchemaDiagramPart parent = (SchemaDiagramPart) getParent();
<img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24"> Rectangle constraint = new Rectangle(location.x, location.y, -1, -1);
<img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24"> parent.setLayoutConstraint(this, tableFigure, constraint);
}</pre>
</font>
We get the 
location of our figure <img src="gef-schema-editor_files/tag_1.gif" align="middle" height="13" width="24">, 
use this to provide a new <code>Rectangle</code> constraint object <img src="gef-schema-editor_files/tag_2.gif" align="middle" height="13" width="24">.
By setting the width and height to <b>-1</b>, we ensure that the preferred width and height are calculated automatically.
We then pass on the constraint to the parent <code>EditPart</code>'s layout manager <img src="gef-schema-editor_files/tag_3.gif" align="middle" height="13" width="24">.
</p><p>
That's all there is to it. 





But how do we know that the preferred size calculation for the 
<code>TableFigure</code> or <code>ColumnFigure</code> 
won't be using some stale cached value? 
If you're interested in the answers to questions like this, read the
sidebar below. 
</p>
<table bgcolor="#ffffcc" border="1" cellpadding="4" width="90%"><tbody><tr>
    <td bgcolor="#0080c0"><font color="#ffffcc" size="+1"><b>Sidebar: Invalidating and Updating Figures</b></font> </td>
  </tr>
<tr><td>
<p>
How does GEF know when to rearrange and resize figures, and which parts of the screen to repaint? 
The key is in the methods in the <code>IFigure</code> interface and in the behavior of the <b>update manager</b>: 

</p><ul>
  <li>
  <p>
  <code>invalidate()</code>: each <code>Figure</code> instance has a <b>valid</b> 
  flag which can be set to <code>true</code> or <code>false</code>. 
  When <code>invalidate()</code> is called:
  </p><ol>
  	<li>the valid flag for the figure is set to false (the figure becomes invalid)
  	</li>
  	<li><code>invalidate()</code> is called on the <code>Figure</code>'s layout manager. 
  	Here, any cached preferred size information that the layout manager holds for the figure is thrown away
  	<br>
  	<br>
  	</li>
  </ol>
  The importance of the invalid state will become more clear when we discuss <code>validate()</code>. 
  <p></p>
  </li> 
  <li>
  <p>  
  <code>revalidate()</code>: this method is used to <code>invalidate()</code> a figure and its parent chain. 
  When called on a figure, this figure invalidates itself and then 
  calls its parent's <code>revalidate()</code> method. 
  The hierarchy's root figure (one with no parent) is finally placed on the update manager's queue of 
  <b>invalid root figures</b>, 
  that is, figures that need to be validated.
  </p> 
  <p> 
  <code>revalidate()</code> is called automatically when changes to figures occur which are likely to affect the bounds of 
  parent figures. 
  Its role can be clearly seen in its usages in the <code>Figure</code> and <code>Label</code> classes draw2d package, shown below:
</p><p>
<img src="gef-schema-editor_files/revalidate-s.JPG" align="middle" height="274" width="259">
</p> 
<p>
  In our example of adding a column label to a table, <code>revalidate()</code> is automatically called when the new column label is added to the 
  <code>ColumnsFigure</code> instance using the <code>IFigure.addFigure(IFigure, Object, int)</code> method. 
  This is why correct resizing of the table occurs without having to invalidate any figures in our 
  example's code.
  </p> 
	<p>
</p><p>
<img src="gef-schema-editor_files/tip.gif" height="13" width="62"> If no method is called which itself automatically invokes <code>revalidate()</code>,
you may need to invoke this method yourself in your application code to correctly update the display. 
</p>
  <p></p>  
  </li>
  <li>  
  <p> 
  <code>repaint()</code>: in the same way that <code>revalidate()</code> queues a figure with the update manager for validating, 
  this method queues the figure's bounds as a <i>dirty region</i> for repainting. 
  Like <code>revalidate()</code>, this method is automatically called in many places in draw2d, such as when the size of a figure changes.
  You are most likely to need to call this method in your application code if implementing custom subclasses of <code>Figure</code>.  
  </p>
  </li>   
  <li>
  <p> 
  <code>validate()</code>: this finishes the job that <code>revalidate()</code> started. 
  The update manager calls <code>validate()</code> on each of the invalid root figures on the queue. 
  During the <code>validate()</code> execution the following happens:
  </p><ol>
  	<li>the figure's valid flag is set back to true</li>
  	<li>layout takes place - if the figure has a layout manager 
  then its <code>layout()</code> 
  method is called
  	</li>
  	<li>
  	the figure then validates each of its invalid children
  	</li>
  	<br>
  </ol>
  The value of <code>revalidate()</code> is in helping to ensure that 
  only figures that <i>need</i> to participate in the validate and layout process 
  can be correctly flagged as invalid before this process begins.  
  <p></p>
  <p>
  After validating its invalid root figures, the update manager will repaint the enclosing rectangle for regions marked as <i>dirty</i>
   via the <code>repaint()</code> method.
  </p>
  </li>
</ul>
<p></p>
</td></tr></tbody></table>

<h2>Conclusion</h2>
<p>
We've covered quite a lot of ground in this article.  
Most significantly, we've talked about how you can use the 
basic building blocks of a GEF application to easily build an application which adheres to a clean MVC design. 
With the exception of the direct editing functionality, most
of the other types of editing operations work in a very similar way to the simple column adding example presented.
Of course, all of the building blocks need to be put together in the 
context of an Eclipse editor. Space limitations preclude any discussion of these
topics, but interested readers can peruse the source code, as well as that of the official GEF examples, 
to see how this can be done. 
</p>
<p>
For more information on GEF, look at the Eclipse platform documentation, 
available via Eclipse online help if you download and install the GEF SDK. 
<a href="http://www-106.ibm.com/developerworks/opensource/library/os-gef/" target="_blank">How to Get Started with the GEF</a> 
  gives a good introduction to GEF basics. <a href="http://www.eclipse.org/articles/Article-GEF-Draw2d/GEF-Draw2d.html">Display a UML Diagram using Draw2D</a>
  is a good starting point for those unfamiliar with Eclipse draw2d. <a href="http://publib-b.boulder.ibm.com/Redbooks.nsf/RedbookAbstracts/sg246302.html?Open" target="_blank">
  Eclipse Development using the Graphical Editing Framework and the Eclipse Modeling Framework</a> 
  is an IBM Redbook providing more detailed coverage of GEF and EMF.
  You will also need to install EMF to get the Redbook examples to work.
</p>
<h2>Acknowledgements</h2>
<p>
Thanks to Randy Hudson and Jim des Rivières for their thorough and careful reviews, 
which have been very helpful in improving both the technical accuracy and readability of 
this article.
</p><h2>Source Code</h2>
<p> To run the example or view the source code for this article, download and 
  unzip <a href="http://www.eclipse.org/articles/Article-GEF-editor/schemaeditor.zip">schemaeditor.zip</a> into your <i>eclipse/</i> 
  subdirectory. Note that you will need Eclipse 3.0 or later to run the examples.</p>

</body></html>